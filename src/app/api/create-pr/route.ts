import { NextRequest, NextResponse } from "next/server";
import {
  getBranchRef,
  createBranch,
  getFileWithSha,
  updateFile,
  createPullRequest,
  getDefaultBranch,
} from "@/lib/github-write";
import { FixSuggestion, CodeChange } from "@/types/fix-suggestion";
import { Blocker } from "@/types/analysis";

interface CreatePRRequest {
  repoUrl: string;
  suggestion: FixSuggestion;
  blocker: Blocker;
  token: string;
}

function parseRepoUrl(url: string): { owner: string; repo: string } | null {
  const match = url.match(/github\.com\/([^/]+)\/([^/]+)/);
  if (!match) return null;
  return { owner: match[1], repo: match[2].replace(/\.git$/, "") };
}

function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-|-$/g, "")
    .slice(0, 30);
}

function applyCodeChange(content: string, change: CodeChange): string {
  const lines = content.split("\n");
  const startIdx = change.startLine - 1;
  const endIdx = change.endLine;

  // Replace lines from startLine to endLine with suggested code
  const before = lines.slice(0, startIdx);
  const after = lines.slice(endIdx);
  const newLines = change.suggestedCode.split("\n");

  return [...before, ...newLines, ...after].join("\n");
}

function generatePRBody(blocker: Blocker, suggestion: FixSuggestion): string {
  const lines: string[] = [];

  lines.push(`## Fix: ${blocker.title}`);
  lines.push("");
  lines.push(`**Severity**: ${blocker.severity}`);
  lines.push(`**Category**: ${blocker.category}`);
  lines.push("");
  lines.push("### Summary");
  lines.push(suggestion.summary);
  lines.push("");

  if (suggestion.codeChanges.length > 0) {
    lines.push("### Changes");
    for (const change of suggestion.codeChanges) {
      lines.push(`- \`${change.file}\` (L${change.startLine}-${change.endLine}): ${change.explanation}`);
    }
    lines.push("");
  }

  if (suggestion.packageUpdates.length > 0) {
    lines.push("### Package Updates");
    for (const update of suggestion.packageUpdates) {
      const version = update.currentVersion
        ? `${update.currentVersion} â†’ ${update.suggestedVersion}`
        : update.suggestedVersion;
      lines.push(`- \`${update.package}\`: ${version}`);
    }
    lines.push("");
  }

  lines.push("---");
  lines.push("Generated by [DebtLens](https://github.com/JerryWu0430/DebtLens)");

  return lines.join("\n");
}

export async function POST(req: NextRequest) {
  try {
    const body: CreatePRRequest = await req.json();
    const { repoUrl, suggestion, blocker, token } = body;

    if (!token) {
      return NextResponse.json({ error: "GitHub token required" }, { status: 401 });
    }

    if (!repoUrl || !suggestion || !blocker) {
      return NextResponse.json({ error: "Missing required fields" }, { status: 400 });
    }

    const parsed = parseRepoUrl(repoUrl);
    if (!parsed) {
      return NextResponse.json({ error: "Invalid GitHub URL" }, { status: 400 });
    }

    const { owner, repo } = parsed;

    if (suggestion.codeChanges.length === 0) {
      return NextResponse.json(
        { error: "No code changes to apply" },
        { status: 400 }
      );
    }

    // Get default branch
    const baseBranch = await getDefaultBranch(owner, repo, token);

    // Get base branch SHA
    const { sha: baseSha } = await getBranchRef(owner, repo, baseBranch, token);

    // Create branch name
    const slug = slugify(blocker.title);
    const timestamp = Date.now().toString(36);
    const branchName = `fix/${blocker.id.slice(0, 8)}-${slug}-${timestamp}`;

    // Create new branch
    await createBranch(owner, repo, branchName, baseSha, token);

    // Group changes by file
    const changesByFile = new Map<string, CodeChange[]>();
    for (const change of suggestion.codeChanges) {
      const existing = changesByFile.get(change.file) || [];
      existing.push(change);
      changesByFile.set(change.file, existing);
    }

    // Apply changes to each file
    for (const [filePath, changes] of Array.from(changesByFile.entries())) {
      // Get current file content
      const { content, sha: fileSha } = await getFileWithSha(
        owner,
        repo,
        filePath,
        branchName,
        token
      );

      // Sort changes by line number descending to apply from bottom to top
      const sortedChanges = [...changes].sort((a, b) => b.startLine - a.startLine);

      let updatedContent = content;
      for (const change of sortedChanges) {
        updatedContent = applyCodeChange(updatedContent, change);
      }

      // Commit the changes
      await updateFile(
        owner,
        repo,
        filePath,
        updatedContent,
        `fix(${blocker.category}): ${blocker.title}`,
        branchName,
        fileSha,
        token
      );
    }

    // Create PR
    const prBody = generatePRBody(blocker, suggestion);
    const prTitle = `fix(${blocker.category}): ${blocker.title}`;

    const { url: prUrl, number: prNumber } = await createPullRequest(
      owner,
      repo,
      prTitle,
      prBody,
      branchName,
      baseBranch,
      token
    );

    return NextResponse.json({
      prUrl,
      prNumber,
      branchName,
    });
  } catch (err) {
    console.error("Create PR error:", err);
    return NextResponse.json(
      { error: err instanceof Error ? err.message : "Failed to create PR" },
      { status: 500 }
    );
  }
}
